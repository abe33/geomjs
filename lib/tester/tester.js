// Generated by CoffeeScript 1.4.0
(function() {
  var Tester;

  Tester = (function() {
    var colorPalette;

    colorPalette = {
      shapeStroke: '#ff0000',
      shapeFill: 'rgba(255,0,0,0.2)',
      bounds: 'rgba(133, 153, 0, 0.3)',
      intersections: '#268bd2',
      intersections2: 'white',
      text: '#93a1a1',
      mobile: '#b58900',
      vertices: '#d33682'
    };

    function Tester(geometry, options) {
      this.geometry = geometry;
      this.options = options;
      this.pathPosition = 0;
      this.random = new chancejs.Random(new chancejs.MathRandom);
      this.name = this.geometry.classname().toLowerCase();
      this.angle = 0;
      this.angleSpeed = this.random["in"]([4, 5, 6, 7, 8]);
    }

    Tester.prototype.animate = function(t) {
      this.pathPosition += t;
      if (this.pathPosition > 10000) {
        this.pathPosition -= 10000;
      }
      return this.angle += t / this.angleSpeed;
    };

    Tester.prototype.renderShape = function(context) {
      this.geometry.fill(context, colorPalette.shapeFill);
      return this.geometry.stroke(context, colorPalette.shapeStroke);
    };

    Tester.prototype.renderPath = function(context) {
      var pt, tan, tr;
      pt = this.geometry.pathPointAt(this.pathPosition / 10000);
      tan = this.geometry.pathOrientationAt(this.pathPosition / 10000);
      tr = new geomjs.Rectangle(pt.x, pt.y, 6, 6, tan);
      return tr.stroke(context, colorPalette.mobile);
    };

    Tester.prototype.renderSurface = function(context) {
      var i, pt, _i, _results;
      context.fillStyle = colorPalette.shapeStroke;
      _results = [];
      for (i = _i = 0; _i <= 100; i = ++_i) {
        pt = this.geometry.randomPointInSurface(this.random);
        _results.push(context.fillRect(pt.x, pt.y, 1, 1));
      }
      return _results;
    };

    Tester.prototype.renderBounds = function(context) {
      var r;
      context.strokeStyle = colorPalette.bounds;
      r = this.geometry.boundingBox();
      return context.strokeRect(r.x, r.y, r.width, r.height);
    };

    Tester.prototype.renderClosedGeometry = function(context) {
      var c, pt1, pt2, pt3;
      c = this.geometry.center();
      pt1 = this.geometry.pointAtAngle(this.angle);
      pt2 = this.geometry.pointAtAngle(this.angle - 120);
      pt3 = this.geometry.pointAtAngle(this.angle + 120);
      context.fillStyle = colorPalette.intersections;
      context.strokeStyle = colorPalette.intersections;
      context.fillRect(pt1.x - 2, pt1.y - 2, 4, 4);
      context.fillRect(pt2.x - 2, pt2.y - 2, 4, 4);
      context.fillRect(pt3.x - 2, pt3.y - 2, 4, 4);
      context.beginPath();
      context.moveTo(pt1.x, pt1.y);
      context.lineTo(c.x, c.y);
      context.lineTo(pt2.x, pt2.y);
      context.moveTo(c.x, c.y);
      context.lineTo(pt3.x, pt3.y);
      return context.stroke();
    };

    Tester.prototype.renderVertices = function(context) {
      return this.geometry.drawVertices(context, colorPalette.vertices);
    };

    Tester.prototype.render = function(context) {
      if ((this.geometry.stroke != null) && (this.geometry.fill != null)) {
        this.renderShape(context);
      }
      if (this.options.bounds && (this.geometry.bounds != null)) {
        this.renderBounds(context);
      }
      if (this.options.path && (this.geometry.pathPointAt != null) && (this.geometry.pathOrientationAt != null)) {
        this.renderPath(context);
      }
      if (this.options.surface && (this.geometry.randomPointInSurface != null)) {
        this.renderSurface(context);
      }
      if (this.options.angle && (this.geometry.center != null) && (this.geometry.pointAtAngle != null)) {
        this.renderClosedGeometry(context);
      }
      if (this.options.vertices && (this.geometry.drawVertices != null)) {
        return this.renderVertices(context);
      }
    };

    return Tester;

  })();

}).call(this);
