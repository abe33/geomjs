// Generated by CoffeeScript 1.4.0
(function() {
  var Cloneable, Ellipsis, Equatable, Formattable, Geometry, Intersections, Memoizable, Parameterizable, Path, Point, Sourcable, Surface, include;

  include = require('./include').include;

  Point = require('./point');

  Equatable = require('./mixins/equatable');

  Formattable = require('./mixins/formattable');

  Geometry = require('./mixins/geometry');

  Surface = require('./mixins/surface');

  Cloneable = require('./mixins/cloneable');

  Memoizable = require('./mixins/memoizable');

  Sourcable = require('./mixins/sourcable');

  Path = require('./mixins/path');

  Intersections = require('./mixins/intersections');

  Parameterizable = require('./mixins/parameterizable');

  Ellipsis = (function() {
    var PROPERTIES;

    PROPERTIES = ['radius1', 'radius2', 'x', 'y', 'rotation', 'segments'];

    include([
      Equatable.apply(null, PROPERTIES), Formattable.apply(null, ['Ellipsis'].concat(PROPERTIES)), Parameterizable('ellipsisFrom', {
        radius1: 1,
        radius2: 1,
        x: 0,
        y: 0,
        rotation: 0,
        segments: 36
      }), Sourcable.apply(null, ['geomjs.Ellipsis'].concat(PROPERTIES)), Cloneable, Memoizable, Geometry, Surface, Path, Intersections
    ])["in"](Ellipsis);

    function Ellipsis(r1, r2, x, y, rot, segments) {
      var _ref;
      _ref = this.ellipsisFrom(r1, r2, x, y, rot, segments), this.radius1 = _ref.radius1, this.radius2 = _ref.radius2, this.x = _ref.x, this.y = _ref.y, this.rotation = _ref.rotation, this.segments = _ref.segments;
    }

    Ellipsis.prototype.center = function() {
      return new Point(this.x, this.y);
    };

    Ellipsis.prototype.left = function() {
      return Math.min.apply(Math, this.xBounds());
    };

    Ellipsis.prototype.right = function() {
      return Math.max.apply(Math, this.xBounds());
    };

    Ellipsis.prototype.bottom = function() {
      return Math.max.apply(Math, this.yBounds());
    };

    Ellipsis.prototype.top = function() {
      return Math.min.apply(Math, this.yBounds());
    };

    Ellipsis.prototype.xBounds = function() {
      var phi, t,
        _this = this;
      phi = Math.degToRad(this.rotation);
      t = Math.atan(-this.radius2 * Math.tan(phi) / this.radius1);
      return [t, t + Math.PI].map(function(t) {
        return _this.x + _this.radius1 * Math.cos(t) * Math.cos(phi) - _this.radius2 * Math.sin(t) * Math.sin(phi);
      });
    };

    Ellipsis.prototype.yBounds = function() {
      var phi, t,
        _this = this;
      phi = Math.degToRad(this.rotation);
      t = Math.atan(this.radius2 * (Math.cos(phi) / Math.sin(phi)) / this.radius1);
      return [t, t + Math.PI].map(function(t) {
        return _this.y + _this.radius1 * Math.cos(t) * Math.sin(phi) + _this.radius2 * Math.sin(t) * Math.cos(phi);
      });
    };

    Ellipsis.prototype.points = function() {
      var n;
      if (this.memoized('points')) {
        this.memoFor('points').concat();
      }
      return this.memoize('points', (function() {
        var _i, _ref, _results;
        _results = [];
        for (n = _i = 0, _ref = this.segments; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
          _results.push(this.pathPointAt(n / this.segments));
        }
        return _results;
      }).call(this));
    };

    Ellipsis.prototype.triangles = function() {
      var center, i, points, triangles, _i, _ref;
      if (this.memoized('triangles')) {
        return this.memoFor('triangles');
      }
      triangles = [];
      points = this.points();
      center = this.center();
      for (i = _i = 1, _ref = points.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        triangles.push(new Triangle(center, points[i - 1], points[i]));
      }
      return this.memoize('triangles', triangles);
    };

    Ellipsis.prototype.closedGeometry = function() {
      return true;
    };

    Ellipsis.prototype.pointAtAngle = function(angle) {
      var center, vec, _ref;
      center = this.center();
      vec = center.add(Math.cos(Math.degToRad(angle)) * 10000, Math.sin(Math.degToRad(angle)) * 10000);
      return (_ref = this.intersections({
        points: function() {
          return [center, vec];
        }
      })) != null ? _ref[0] : void 0;
    };

    Ellipsis.prototype.acreage = function() {
      return Math.PI * this.radius1 * this.radius2;
    };

    Ellipsis.prototype.randomPointInSurface = function(random) {
      var center, dif, pt;
      if (random == null) {
        random = new chancejs.Random(new chancejs.MathRandom);
      }
      pt = this.pathPointAt(random.get());
      center = this.center();
      dif = pt.subtract(center);
      return center.add(dif.scale(Math.sqrt(random.random())));
    };

    Ellipsis.prototype.contains = function(xOrPt, y) {
      var a, c, d, p, p2;
      p = new Point(xOrPt, y);
      c = this.center();
      d = p.subtract(c);
      a = d.angle();
      p2 = this.pointAtAngle(a);
      return c.distance(p2) >= c.distance(p);
    };

    Ellipsis.prototype.length = function() {
      return Math.PI * (3 * (this.radius1 + this.radius2) - Math.sqrt((3 * this.radius1 + this.radius2) * (this.radius1 + this.radius2 * 3)));
    };

    Ellipsis.prototype.pathPointAt = function(n) {
      var a, p;
      a = n * Math.PI * 2;
      p = new Point(Math.cos(a) * this.radius1, Math.sin(a) * this.radius2);
      return this.center().add(p.rotate(this.rotation));
    };

    Ellipsis.prototype.drawPath = function(context) {
      context.save();
      context.translate(this.x, this.y);
      context.rotate(Math.degToRad(this.rotation));
      context.scale(this.radius1, this.radius2);
      context.beginPath();
      context.arc(0, 0, 1, 0, Math.PI * 2);
      context.closePath();
      return context.restore();
    };

    Ellipsis.prototype.memoizationKey = function() {
      return "" + this.radius1 + ";" + this.radius2 + ";" + this.x + ";" + this.y + ";" + this.segments;
    };

    return Ellipsis;

  })();

  module.exports = Ellipsis;

}).call(this);
