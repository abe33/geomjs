// Generated by CoffeeScript 1.4.0
(function() {
  var Ellipsis, Equatable, Formattable, Geometry, Path, Point, Surface;

  Point = require('./point');

  Equatable = require('./equatable');

  Formattable = require('./formattable');

  Geometry = require('./geometry');

  Surface = require('./surface');

  Path = require('./path');

  Ellipsis = (function() {

    Equatable('radius1', 'radius2', 'x', 'y', 'rotation').attachTo(Ellipsis);

    Formattable('Ellipsis', 'radius1', 'radius2', 'x', 'y', 'rotation').attachTo(Ellipsis);

    Geometry.attachTo(Ellipsis);

    function Ellipsis(r1, r2, x, y, rot, segments) {
      var _ref;
      _ref = this.ellipsisFrom(r1, r2, x, y, rot, segments), this.radius1 = _ref[0], this.radius2 = _ref[1], this.x = _ref[2], this.y = _ref[3], this.rotation = _ref[4], this.segments = _ref[5];
    }

    Ellipsis.prototype.center = function() {
      return new Point(this.x, this.y);
    };

    Ellipsis.prototype.acreage = function() {
      return Math.PI * this.radius1 * this.radius2;
    };

    Ellipsis.prototype.length = function() {
      return Math.PI * (3 * (this.radius1 + this.radius2) - Math.sqrt((3 * this.radius1 + this.radius2) * (this.radius1 + this.radius2 * 3)));
    };

    Ellipsis.prototype.closedGeometry = function() {
      return true;
    };

    Ellipsis.prototype.left = function() {
      var phi, t;
      phi = Math.degToRad(this.rotation);
      t = Math.atan(-this.radius2 * Math.tan(phi) / this.radius1) + Math.PI;
      return this.x + this.radius1 * Math.cos(t) * Math.cos(phi) - this.radius2 * Math.sin(t) * Math.sin(phi);
    };

    Ellipsis.prototype.right = function() {
      var phi, t;
      phi = Math.degToRad(this.rotation);
      t = Math.atan(-this.radius2 * Math.tan(phi) / this.radius1);
      return this.x + this.radius1 * Math.cos(t) * Math.cos(phi) - this.radius2 * Math.sin(t) * Math.sin(phi);
    };

    Ellipsis.prototype.bottom = function() {
      var phi, t;
      phi = Math.degToRad(this.rotation);
      t = Math.atan(this.radius2 * Math.cos(phi) / this.radius1);
      return this.y + this.radius1 * Math.sin(t) * Math.cos(phi) + this.radius2 * Math.cos(t) * Math.sin(phi);
    };

    Ellipsis.prototype.top = function() {
      var phi, t;
      phi = Math.degToRad(this.rotation);
      t = Math.atan(this.radius2 * Math.cos(phi) / this.radius1) + Math.PI;
      return this.y + this.radius1 * Math.sin(t) * Math.cos(phi) + this.radius2 * Math.cos(t) * Math.sin(phi);
    };

    Ellipsis.prototype.clone = function() {
      return new Ellipsis(this);
    };

    Ellipsis.prototype.drawPath = function(context) {
      context.save();
      context.translate(this.x, this.y);
      context.rotate(Math.degToRad(this.rotation));
      context.scale(this.radius1, this.radius2);
      context.beginPath();
      context.arc(0, 0, 1, 0, Math.PI * 2);
      context.closePath();
      return context.restore();
    };

    Ellipsis.prototype.points = function() {
      var n, step, _i, _ref, _results;
      step = 360 / this.segments;
      _results = [];
      for (n = _i = 0, _ref = this.segments; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.pathPointAt(n * step));
      }
      return _results;
    };

    Ellipsis.prototype.pathPointAt = function(n) {
      var a, p;
      a = Math.degToRad(n);
      p = new Point(Math.cos(a) * this.radius1, Math.sin(a) * this.radius2);
      return this.center().add(p.rotate(this.rotation));
    };

    Ellipsis.prototype.ellipsisFrom = function(radius1, radius2, x, y, rotation, segments) {
      var _ref;
      if (typeof radius1 === 'object') {
        _ref = radius1, radius1 = _ref.radius1, radius2 = _ref.radius2, x = _ref.x, y = _ref.y, rotation = _ref.rotation, segments = _ref.segments;
      }
      if (!Point.isFloat(radius1)) {
        radius1 = 1;
      }
      if (!Point.isFloat(radius2)) {
        radius2 = 1;
      }
      if (!Point.isFloat(x)) {
        x = 0;
      }
      if (!Point.isFloat(y)) {
        y = 0;
      }
      if (!Point.isFloat(rotation)) {
        rotation = 0;
      }
      if (!Point.isFloat(segments)) {
        segments = 36;
      }
      return [radius1, radius2, x, y, rotation, segments];
    };

    return Ellipsis;

  })();

  module.exports = Ellipsis;

}).call(this);
