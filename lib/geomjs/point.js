// Generated by CoffeeScript 1.4.0
(function() {
  var Point;

  Point = (function() {

    Point.isPoint = function(pt) {
      return (pt != null) && (pt.x != null) && (pt.y != null);
    };

    Point.isFloat = function(n) {
      return typeof n === 'number' || !isNaN(parseFloat(n));
    };

    Point.polar = function(angle, length) {
      if (length == null) {
        length = 1;
      }
      return new Point(Math.sin(angle) * length, Math.cos(angle) * length);
    };

    Point.interpolate = function() {
      var args, dif, i, pos, pt1, pt2, v, _i, _len;
      args = [];
      for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
        v = arguments[i];
        args[i] = v;
      }
      if (this.isPoint(args[0])) {
        pt1 = args.shift();
      } else if (this.isFloat(args[0]) && this.isFloat(args[1])) {
        pt1 = new Point(args[0], args[1]);
        args.splice(0, 2);
      } else {
        this.pointNotFound(args, 'first');
      }
      if (this.isPoint(args[0])) {
        pt2 = args.shift();
      } else if (this.isFloat(args[0]) && this.isFloat(args[1])) {
        pt2 = new Point(args[0], args[1]);
        args.splice(0, 2);
      } else {
        this.pointNotFound(args, 'second');
      }
      pos = parseFloat(args.shift());
      if (isNaN(pos)) {
        this.missingPosition(pos);
      }
      dif = pt2.subtract(pt1);
      return new Point(pt1.x + dif.x * pos, pt1.y + dif.y * pos);
    };

    Point.missingPosition = function(pos) {
      throw new Error("Point.interpolate require a position but " + pos + " was given");
    };

    Point.pointNotFound = function(args, pos) {
      throw new Error("Can't find the " + pos + " point in Point.interpolate arguments " + args);
    };

    function Point(x, y) {
      var _ref, _ref1;
      _ref = this.coordsFrom(x, y), x = _ref[0], y = _ref[1];
      _ref1 = this.defaultToZero(x, y), this.x = _ref1[0], this.y = _ref1[1];
    }

    Point.prototype.length = function() {
      return Math.sqrt((this.x * this.x) + (this.y * this.y));
    };

    Point.prototype.normalize = function(length) {
      var l;
      if (length == null) {
        length = 1;
      }
      if (isNaN(parseFloat(length))) {
        this.invalidLength(length);
      }
      l = this.length();
      return new Point(this.x / l * length, this.y / l * length);
    };

    Point.prototype.add = function(x, y) {
      var _ref, _ref1;
      _ref = this.coordsFrom(x, y), x = _ref[0], y = _ref[1];
      _ref1 = this.defaultToZero(x, y), x = _ref1[0], y = _ref1[1];
      return new Point(this.x + x, this.y + y);
    };

    Point.prototype.subtract = function(x, y) {
      var _ref, _ref1;
      _ref = this.coordsFrom(x, y), x = _ref[0], y = _ref[1];
      _ref1 = this.defaultToZero(x, y), x = _ref1[0], y = _ref1[1];
      return new Point(this.x - x, this.y - y);
    };

    Point.prototype.dot = function(x, y) {
      var _ref;
      if (!(x != null) && !(y != null)) {
        this.noPoint('dot');
      }
      _ref = this.coordsFrom(x, y, true), x = _ref[0], y = _ref[1];
      return this.x * x + this.y * y;
    };

    Point.prototype.distance = function(x, y) {
      var _ref;
      if (!(x != null) && !(y != null)) {
        this.noPoint('dot');
      }
      _ref = this.coordsFrom(x, y, true), x = _ref[0], y = _ref[1];
      return this.subtract(x, y).length();
    };

    Point.prototype.paste = function(x, y) {
      var _ref;
      _ref = this.coordsFrom(x, y), x = _ref[0], y = _ref[1];
      if (typeof x === 'number') {
        this.x = x;
      }
      if (typeof y === 'number') {
        this.y = y;
      }
      return this;
    };

    Point.prototype.coordsFrom = function(x, y, strict) {
      var _ref;
      if (strict == null) {
        strict = false;
      }
      if (typeof x === 'object') {
        if (strict && !this.isPoint(x)) {
          this.notAPoint(x);
        }
        if (x != null) {
          _ref = x, x = _ref.x, y = _ref.y;
        }
      }
      if (typeof x === 'string') {
        x = parseFloat(x);
      }
      if (typeof y === 'string') {
        y = parseFloat(y);
      }
      return [x, y];
    };

    Point.prototype.defaultToZero = function(x, y) {
      x = isNaN(x) ? 0 : x;
      y = isNaN(y) ? 0 : y;
      return [x, y];
    };

    Point.prototype.isPoint = function(pt) {
      return Point.isPoint(pt);
    };

    Point.prototype.notAPoint = function(pt) {
      throw new Error("" + pt + " isn't a point-like object");
    };

    Point.prototype.noPoint = function(method) {
      throw new Error("" + method + " was called without arguments");
    };

    Point.prototype.invalidLength = function(l) {
      throw new Error("Invalid length " + l + " provided");
    };

    Point.prototype.clone = function() {
      return new Point(this);
    };

    Point.prototype.toString = function() {
      return "[object Point(" + this.x + "," + this.y + ")]";
    };

    return Point;

  })();

  module.exports = Point;

}).call(this);
