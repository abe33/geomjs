// Generated by CoffeeScript 1.4.0
(function() {
  var Cloneable, Equatable, Formattable, Point, Sourcable;

  require('./math');

  Cloneable = require('./mixins/cloneable');

  Equatable = require('./mixins/equatable');

  Formattable = require('./mixins/formattable');

  Sourcable = require('./mixins/sourcable');

  Point = (function() {

    Equatable('x', 'y').attachTo(Point);

    Formattable('Point', 'x', 'y').attachTo(Point);

    Sourcable('geomjs.Point', 'x', 'y').attachTo(Point);

    Cloneable.attachTo(Point);

    Point.isPoint = function(pt) {
      return (pt != null) && (pt.x != null) && (pt.y != null);
    };

    Point.pointFrom = function(xOrPt, y, strict) {
      var x;
      if (strict == null) {
        strict = false;
      }
      x = xOrPt;
      if ((xOrPt != null) && typeof xOrPt === 'object') {
        x = xOrPt.x, y = xOrPt.y;
      }
      if (strict && (isNaN(x) || isNaN(y))) {
        this.notAPoint([x, y]);
      }
      return {
        x: x,
        y: y
      };
    };

    Point.polar = function(angle, length) {
      if (length == null) {
        length = 1;
      }
      return new Point(Math.sin(angle) * length, Math.cos(angle) * length);
    };

    Point.interpolate = function(pt1, pt2, pos) {
      var args, dif, extract, i, v, _i, _len,
        _this = this;
      args = [];
      for (i = _i = 0, _len = arguments.length; _i < _len; i = ++_i) {
        v = arguments[i];
        args[i] = v;
      }
      extract = function(args, name) {
        var pt;
        pt = null;
        if (_this.isPoint(args[0])) {
          pt = args.shift();
        } else if (Math.isFloat(args[0]) && Math.isFloat(args[1])) {
          pt = new Point(args[0], args[1]);
          args.splice(0, 2);
        } else {
          _this.missingPoint(args, name);
        }
        return pt;
      };
      pt1 = extract(args, 'first');
      pt2 = extract(args, 'second');
      pos = parseFloat(args.shift());
      if (isNaN(pos)) {
        this.missingPosition(pos);
      }
      dif = pt2.subtract(pt1);
      return new Point(pt1.x + dif.x * pos, pt1.y + dif.y * pos);
    };

    Point.missingPosition = function(pos) {
      throw new Error("Point.interpolate require a position but " + pos + " was given");
    };

    Point.missingPoint = function(args, pos) {
      throw new Error("Can't find the " + pos + " point in Point.interpolate arguments " + args);
    };

    Point.notAPoint = function(args) {
      throw new Error("" + args + " is not a point");
    };

    function Point(x, y) {
      if (x != null) {
        y = x.y || y;
      }
      if (isNaN(y)) {
        y = 0;
      }
      if (x != null) {
        x = x.x || x;
      }
      if (isNaN(x)) {
        x = 0;
      }
      this.x = x;
      this.y = y;
    }

    Point.prototype.length = function() {
      return Math.sqrt((this.x * this.x) + (this.y * this.y));
    };

    Point.prototype.angle = function() {
      return Math.radToDeg(Math.atan2(this.y, this.x));
    };

    Point.prototype.angleWith = function(x, y) {
      var d, isPoint;
      if (!(x != null) && !(y != null)) {
        this.noPoint('dot');
      }
      isPoint = this.isPoint(x);
      y = isPoint ? x.y : y;
      x = isPoint ? x.x : x;
      if (isNaN(x) || isNaN(y)) {
        Point.notAPoint([x, y]);
      }
      d = this.normalize().dot(new Point(x, y).normalize());
      return Math.radToDeg(Math.acos(Math.abs(d)) * (d < 0 ? -1 : 1));
    };

    Point.prototype.normalize = function(length) {
      var l;
      if (length == null) {
        length = 1;
      }
      if (!Math.isFloat(length)) {
        this.invalidLength(length);
      }
      l = this.length();
      return new Point(this.x / l * length, this.y / l * length);
    };

    Point.prototype.add = function(x, y) {
      if (x != null) {
        y = x.y || y;
      }
      if (isNaN(y)) {
        y = 0;
      }
      if (x != null) {
        x = x.x || x;
      }
      if (isNaN(x)) {
        x = 0;
      }
      return new Point(this.x + x, this.y + y);
    };

    Point.prototype.subtract = function(x, y) {
      if (x != null) {
        y = x.y || y;
      }
      if (isNaN(y)) {
        y = 0;
      }
      if (x != null) {
        x = x.x || x;
      }
      if (isNaN(x)) {
        x = 0;
      }
      return new Point(this.x - x, this.y - y);
    };

    Point.prototype.dot = function(x, y) {
      var isPoint;
      if (!(x != null) && !(y != null)) {
        this.noPoint('dot');
      }
      isPoint = this.isPoint(x);
      y = isPoint ? x.y : y;
      x = isPoint ? x.x : x;
      if (isNaN(x) || isNaN(y)) {
        Point.notAPoint([x, y]);
      }
      return this.x * x + this.y * y;
    };

    Point.prototype.distance = function(x, y) {
      var isPoint;
      if (!(x != null) && !(y != null)) {
        this.noPoint('distance');
      }
      isPoint = this.isPoint(x);
      y = isPoint ? x.y : y;
      x = isPoint ? x.x : x;
      if (isNaN(x) || isNaN(y)) {
        Point.notAPoint([x, y]);
      }
      return this.subtract(x, y).length();
    };

    Point.prototype.scale = function(n) {
      if (!Math.isFloat(n)) {
        this.invalidScale(n);
      }
      return new Point(this.x * n, this.y * n);
    };

    Point.prototype.rotate = function(n) {
      var a, l, x, y;
      if (!Math.isFloat(n)) {
        this.invalidRotation(n);
      }
      l = this.length();
      a = Math.atan2(this.y, this.x) + Math.degToRad(n);
      x = Math.cos(a) * l;
      y = Math.sin(a) * l;
      return new Point(x, y);
    };

    Point.prototype.rotateAround = function(x, y, a) {
      var isPoint;
      isPoint = this.isPoint(x);
      if (isPoint) {
        a = y;
      }
      y = isPoint ? x.y : y;
      x = isPoint ? x.x : x;
      return this.subtract(x, y).rotate(a).add(x, y);
    };

    Point.prototype.isPoint = Point.isPoint;

    Point.prototype.pointFrom = Point.pointFrom;

    Point.prototype.defaultToZero = function(x, y) {
      x = isNaN(x) ? 0 : x;
      y = isNaN(y) ? 0 : y;
      return [x, y];
    };

    Point.prototype.paste = function(x, y) {
      var isObject;
      if (!(x != null) && !(y != null)) {
        return this;
      }
      isObject = (x != null) && typeof x === 'object';
      y = isObject ? x.y : y;
      x = isObject ? x.x : x;
      if (!isNaN(x)) {
        this.x = x;
      }
      if (!isNaN(y)) {
        this.y = y;
      }
      return this;
    };

    Point.prototype.noPoint = function(method) {
      throw new Error("" + method + " was called without arguments");
    };

    Point.prototype.invalidLength = function(l) {
      throw new Error("Invalid length " + l + " provided");
    };

    Point.prototype.invalidScale = function(s) {
      throw new Error("Invalid scale " + s + " provided");
    };

    Point.prototype.invalidRotation = function(a) {
      throw new Error("Invalid rotation " + a + " provided");
    };

    return Point;

  })();

  module.exports = Point;

}).call(this);
