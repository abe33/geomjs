// Generated by CoffeeScript 1.4.0
(function() {
  var Geometry, Point;

  Point = require('./point');

  Geometry = (function() {

    function Geometry() {}

    Geometry.attachTo = function(klass) {
      var k, v, _results;
      _results = [];
      for (k in this) {
        v = this[k];
        if (k !== 'attachTo') {
          _results.push(klass.prototype[k] = v);
        }
      }
      return _results;
    };

    Geometry.intersects = function(geometry) {
      var output;
      output = false;
      this.eachIntersections(geometry, function(intersection) {
        return output = true;
      });
      return output;
    };

    Geometry.intersections = function(geometry) {
      var output;
      output = [];
      this.eachIntersections(geometry, function(intersection) {
        output.push(intersection);
        return false;
      });
      if (output.length > 0) {
        return output;
      } else {
        return null;
      }
    };

    Geometry.eachIntersections = function(geometry, block) {
      var cross, d1, d2, d3, d4, dif1, dif2, ev1, ev2, i, j, length1, length2, output, points1, points2, sv1, sv2, _i, _j, _ref, _ref1;
      points1 = this.points();
      points2 = geometry.points();
      length1 = points1.length;
      length2 = points2.length;
      output = [];
      for (i = _i = 0, _ref = length1 - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        sv1 = points1[i];
        ev1 = points1[i + 1];
        dif1 = ev1.subtract(sv1);
        for (j = _j = 0, _ref1 = length2 - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          sv2 = points2[j];
          ev2 = points2[j + 1];
          dif2 = ev2.subtract(sv2);
          cross = this.perCrossing(sv1, dif1, sv2, dif2);
          d1 = cross.subtract(ev1);
          d2 = cross.subtract(sv1);
          d3 = cross.subtract(ev2);
          d4 = cross.subtract(sv2);
          if (d1.length() <= dif1.length() && d2.length() <= dif1.length() && d3.length() <= dif2.length() && d4.length() <= dif2.length()) {
            if (block.call(this, cross)) {
              return;
            }
          }
        }
      }
    };

    Geometry.perCrossing = function(start1, dir1, start2, dir2) {
      var cx, cy, perP1, perP2, t, v3bx, v3by;
      v3bx = start2.x - start1.x;
      v3by = start2.y - start1.y;
      perP1 = v3bx * dir2.y - v3by * dir2.x;
      perP2 = dir1.x * dir2.y - dir1.y * dir2.x;
      t = perP1 / perP2;
      cx = start1.x + dir1.x * t;
      cy = start1.y + dir1.y * t;
      return new Point(cx, cy);
    };

    return Geometry;

  })();

  module.exports = Geometry;

}).call(this);
