// Generated by CoffeeScript 1.4.0
(function() {
  var Cloneable, Equatable, Formattable, Geometry, Intersections, Parameterizable, Path, Point, Proxyable, Rectangle, Sourcable, Surface, Triangulable, chancejs, include;

  include = require('./include').include;

  Point = require('./point');

  Equatable = require('./mixins/equatable');

  Formattable = require('./mixins/formattable');

  Cloneable = require('./mixins/cloneable');

  Sourcable = require('./mixins/sourcable');

  Triangulable = require('./mixins/triangulable');

  Proxyable = require('./mixins/proxyable');

  Parameterizable = require('./mixins/parameterizable');

  Geometry = require('./mixins/geometry');

  Surface = require('./mixins/surface');

  Path = require('./mixins/path');

  Intersections = require('./mixins/intersections');

  chancejs = require('chancejs');

  Rectangle = (function() {
    var PROPERTIES, iterators, k;

    PROPERTIES = ['x', 'y', 'width', 'height', 'rotation'];

    include([
      Equatable.apply(null, PROPERTIES), Formattable.apply(null, ['Rectangle'].concat(PROPERTIES)), Sourcable.apply(null, ['geomjs.Rectangle'].concat(PROPERTIES)), Parameterizable('rectangleFrom', {
        x: NaN,
        y: NaN,
        width: NaN,
        height: NaN,
        rotation: NaN
      }), Cloneable, Geometry, Surface, Path, Triangulable, Proxyable, Intersections
    ])["in"](Rectangle);

    Rectangle.eachRectangleRectangleIntersections = function(geom1, geom2, block, data) {
      var p, _i, _len, _ref;
      if (data == null) {
        data = false;
      }
      if (geom1.equals(geom2)) {
        _ref = geom1.points();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          p = _ref[_i];
          if (block.call(this, p)) {
            return;
          }
        }
      } else {
        return this.eachIntersections(geom1, geom2, block, data);
      }
    };

    iterators = Intersections.iterators;

    k = 'RectangleRectangle';

    iterators[k] = Rectangle.eachRectangleRectangleIntersections;

    function Rectangle(x, y, width, height, rotation) {
      var args;
      args = this.defaultToZero(this.rectangleFrom.apply(this, arguments));
      this.x = args.x, this.y = args.y, this.width = args.width, this.height = args.height, this.rotation = args.rotation;
    }

    Rectangle.proxyable('PointList', {
      corners: function() {
        return [this.topLeft(), this.topRight(), this.bottomRight(), this.bottomLeft()];
      }
    });

    Rectangle.proxyable('Point', {
      topLeft: function() {
        return new Point(this.x, this.y);
      },
      topRight: function() {
        return this.topLeft().add(this.topEdge());
      },
      bottomLeft: function() {
        return this.topLeft().add(this.leftEdge());
      },
      bottomRight: function() {
        return this.topLeft().add(this.topEdge()).add(this.leftEdge());
      }
    });

    Rectangle.proxyable('Point', {
      center: function() {
        return this.topLeft().add(this.diagonal().scale(0.5));
      },
      topEdgeCenter: function() {
        return this.topLeft().add(this.topEdge().scale(0.5));
      },
      bottomEdgeCenter: function() {
        return this.bottomLeft().add(this.topEdge().scale(0.5));
      },
      leftEdgeCenter: function() {
        return this.topLeft().add(this.leftEdge().scale(0.5));
      },
      rightEdgeCenter: function() {
        return this.topRight().add(this.leftEdge().scale(0.5));
      }
    });

    Rectangle.proxyable('PointList', {
      edges: function() {
        return [this.topEdge(), this.topRight(), this.bottomRight(), this.bottomLeft()];
      }
    });

    Rectangle.proxyable('Point', {
      topEdge: function() {
        return new Point(this.width * Math.cos(this.rotation), this.width * Math.sin(this.rotation));
      },
      leftEdge: function() {
        return new Point(this.height * Math.cos(this.rotation + Math.PI / 2), this.height * Math.sin(this.rotation + Math.PI / 2));
      },
      bottomEdge: function() {
        return this.topEdge();
      },
      rightEdge: function() {
        return this.leftEdge();
      },
      diagonal: function() {
        return this.leftEdge().add(this.topEdge());
      }
    });

    Rectangle.prototype.top = function() {
      return Math.min(this.y, this.topRight().y, this.bottomRight().y, this.bottomLeft().y);
    };

    Rectangle.prototype.bottom = function() {
      return Math.max(this.y, this.topRight().y, this.bottomRight().y, this.bottomLeft().y);
    };

    Rectangle.prototype.left = function() {
      return Math.min(this.x, this.topRight().x, this.bottomRight().x, this.bottomLeft().x);
    };

    Rectangle.prototype.right = function() {
      return Math.max(this.x, this.topRight().x, this.bottomRight().x, this.bottomLeft().x);
    };

    Rectangle.prototype.setCenter = function(xOrPt, y) {
      var pt;
      pt = Point.pointFrom(xOrPt, y).subtract(this.center());
      this.x += pt.x;
      this.y += pt.y;
      return this;
    };

    Rectangle.prototype.translate = function(xOrPt, y) {
      var pt;
      pt = Point.pointFrom(xOrPt, y);
      this.x += pt.x;
      this.y += pt.y;
      return this;
    };

    Rectangle.prototype.rotate = function(rotation) {
      var _ref;
      _ref = this.topLeft().rotateAround(this.center(), rotation), this.x = _ref.x, this.y = _ref.y;
      this.rotation += rotation;
      return this;
    };

    Rectangle.prototype.scale = function(scale) {
      var center;
      center = this.center();
      this.width *= scale;
      this.height *= scale;
      this.setCenter(center);
      return this;
    };

    Rectangle.prototype.rotateAroundCenter = Rectangle.prototype.rotate;

    Rectangle.prototype.scaleAroundCenter = Rectangle.prototype.scale;

    Rectangle.prototype.inflateAroundCenter = function(xOrPt, y) {
      var center;
      center = this.center();
      this.inflate(xOrPt, y);
      this.setCenter(center);
      return this;
    };

    Rectangle.prototype.inflate = function(xOrPt, y) {
      var pt;
      pt = Point.pointFrom(xOrPt, y);
      this.width += pt.x;
      this.height += pt.y;
      return this;
    };

    Rectangle.prototype.inflateLeft = function(inflate) {
      var offset, _ref;
      this.width += inflate;
      offset = this.topEdge().normalize(-inflate);
      _ref = this.topLeft().add(offset), this.x = _ref.x, this.y = _ref.y;
      return this;
    };

    Rectangle.prototype.inflateRight = function(inflate) {
      this.width += inflate;
      return this;
    };

    Rectangle.prototype.inflateTop = function(inflate) {
      var offset, _ref;
      this.height += inflate;
      offset = this.leftEdge().normalize(-inflate);
      _ref = this.topLeft().add(offset), this.x = _ref.x, this.y = _ref.y;
      return this;
    };

    Rectangle.prototype.inflateBottom = function(inflate) {
      this.height += inflate;
      return this;
    };

    Rectangle.prototype.inflateTopLeft = function(xOrPt, y) {
      var pt;
      pt = Point.pointFrom(xOrPt, y);
      this.inflateLeft(pt.x);
      this.inflateTop(pt.y);
      return this;
    };

    Rectangle.prototype.inflateTopRight = function(xOrPt, y) {
      var pt;
      pt = Point.pointFrom(xOrPt, y);
      this.inflateRight(pt.x);
      this.inflateTop(pt.y);
      return this;
    };

    Rectangle.prototype.inflateBottomLeft = function(xOrPt, y) {
      var pt;
      pt = Point.pointFrom(xOrPt, y);
      this.inflateLeft(pt.x);
      this.inflateBottom(pt.y);
      return this;
    };

    Rectangle.prototype.inflateBottomRight = function(xOrPt, y) {
      return this.inflate(xOrPt, y);
    };

    Rectangle.prototype.closedGeometry = function() {
      return true;
    };

    Rectangle.proxyable('PointList', {
      points: function() {
        return [this.topLeft(), this.topRight(), this.bottomRight(), this.bottomLeft(), this.topLeft()];
      }
    });

    Rectangle.prototype.pointAtAngle = function(angle) {
      var center, vec, _ref;
      center = this.center();
      vec = center.add(Math.cos(angle) * 10000, Math.sin(angle) * 10000);
      return (_ref = this.intersections({
        points: function() {
          return [center, vec];
        }
      })) != null ? _ref[0] : void 0;
    };

    Rectangle.prototype.acreage = function() {
      return this.width * this.height;
    };

    Rectangle.prototype.contains = function(xOrPt, y) {
      var x, _ref;
      _ref = new Point(xOrPt, y).rotateAround(this.topLeft(), -this.rotation), x = _ref.x, y = _ref.y;
      return ((this.x <= x && x <= this.x + this.width)) && ((this.y <= y && y <= this.y + this.height));
    };

    Rectangle.prototype.randomPointInSurface = function(random) {
      if (random == null) {
        random = new chancejs.Random(new chancejs.MathRandom);
      }
      return this.topLeft().add(this.topEdge().scale(random.get())).add(this.leftEdge().scale(random.get()));
    };

    Rectangle.prototype.length = function() {
      return this.width * 2 + this.height * 2;
    };

    Rectangle.proxyable('Point', {
      pathPointAt: function(n, pathBasedOnLength) {
        var p1, p2, p3, _ref;
        if (pathBasedOnLength == null) {
          pathBasedOnLength = true;
        }
        _ref = this.pathSteps(pathBasedOnLength), p1 = _ref[0], p2 = _ref[1], p3 = _ref[2];
        if (n < p1) {
          return this.topLeft().add(this.topEdge().scale(Math.map(n, 0, p1, 0, 1)));
        } else if (n < p2) {
          return this.topRight().add(this.rightEdge().scale(Math.map(n, p1, p2, 0, 1)));
        } else if (n < p3) {
          return this.bottomRight().add(this.bottomEdge().scale(Math.map(n, p2, p3, 0, 1) * -1));
        } else {
          return this.bottomLeft().add(this.leftEdge().scale(Math.map(n, p3, 1, 0, 1) * -1));
        }
      }
    });

    Rectangle.proxyable('Angle', {
      pathOrientationAt: function(n, pathBasedOnLength) {
        var p, p1, p2, p3, _ref;
        if (pathBasedOnLength == null) {
          pathBasedOnLength = true;
        }
        _ref = this.pathSteps(pathBasedOnLength), p1 = _ref[0], p2 = _ref[1], p3 = _ref[2];
        if (n < p1) {
          p = this.topEdge();
        } else if (n < p2) {
          p = this.rightEdge();
        } else if (n < p3) {
          p = this.bottomEdge().scale(-1);
        } else {
          p = this.leftEdge().scale(-1);
        }
        return p.angle();
      }
    });

    Rectangle.prototype.pathSteps = function(pathBasedOnLength) {
      var l, p1, p2, p3;
      if (pathBasedOnLength == null) {
        pathBasedOnLength = true;
      }
      if (pathBasedOnLength) {
        l = this.length();
        p1 = this.width / l;
        p2 = (this.width + this.height) / l;
        p3 = p1 + p2;
      } else {
        p1 = 1 / 4;
        p2 = 1 / 2;
        p3 = 3 / 4;
      }
      return [p1, p2, p3];
    };

    Rectangle.prototype.drawPath = function(context) {
      context.beginPath();
      context.moveTo(this.x, this.y);
      context.lineTo(this.topRight().x, this.topRight().y);
      context.lineTo(this.bottomRight().x, this.bottomRight().y);
      context.lineTo(this.bottomLeft().x, this.bottomLeft().y);
      context.lineTo(this.x, this.y);
      return context.closePath();
    };

    Rectangle.prototype.paste = function(x, y, width, height, rotation) {
      var v, values, _results;
      values = this.rectangleFrom(x, y, width, height, rotation);
      _results = [];
      for (k in values) {
        v = values[k];
        if (Math.isFloat(v)) {
          _results.push(this[k] = parseFloat(v));
        }
      }
      return _results;
    };

    Rectangle.prototype.defaultToZero = function(values) {
      var v;
      for (k in values) {
        v = values[k];
        if (!Math.isFloat(v)) {
          values[k] = 0;
        }
      }
      return values;
    };

    return Rectangle;

  })();

  module.exports = Rectangle;

}).call(this);
