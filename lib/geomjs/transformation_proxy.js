// Generated by CoffeeScript 1.4.0
(function() {
  var Point, TransformationProxy;

  Point = require('./point');

  TransformationProxy = (function() {

    TransformationProxy.defineProxy = function(key, type) {
      switch (type) {
        case 'PointList':
          return this.prototype[key] = function() {
            var points,
              _this = this;
            points = this.geometry[key].apply(this.geometry, arguments);
            if (this.matrix != null) {
              return points.map(function(pt) {
                return _this.matrix.transformPoint(pt);
              });
            } else {
              return points;
            }
          };
        case 'Point':
          return this.prototype[key] = function() {
            var point;
            point = this.geometry[key].apply(this.geometry, arguments);
            if (this.matrix != null) {
              return this.matrix.transformPoint(point);
            } else {
              return point;
            }
          };
        case 'Angle':
          return this.prototype[key] = function() {
            var angle, vec;
            angle = this.geometry[key].apply(this.geometry, arguments);
            if (this.matrix != null) {
              vec = new Point(Math.cos(Math.degToRad(angle)), Math.sin(Math.degToRad(angle)));
              return this.matrix.transformPoint(vec).angle();
            } else {
              return angle;
            }
          };
      }
    };

    function TransformationProxy(geometry, matrix) {
      this.geometry = geometry;
      this.matrix = matrix;
      this.proxiedMethods = this.detectProxyableMethods(this.geometry);
    }

    TransformationProxy.prototype.proxied = function() {
      var k, v, _ref, _results;
      _ref = this.proxiedMethods;
      _results = [];
      for (k in _ref) {
        v = _ref[k];
        _results.push(k);
      }
      return _results;
    };

    TransformationProxy.prototype.detectProxyableMethods = function(geometry) {
      var k, proxiedMethods, v, _ref;
      proxiedMethods = {};
      _ref = geometry.constructor.prototype;
      for (k in _ref) {
        v = _ref[k];
        if (v.proxyable) {
          proxiedMethods[k] = v.proxyable;
          TransformationProxy.defineProxy(k, v.proxyable);
        }
      }
      return proxiedMethods;
    };

    return TransformationProxy;

  })();

  module.exports = TransformationProxy;

}).call(this);
