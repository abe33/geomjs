// Generated by CoffeeScript 1.4.0
(function() {
  var Circle, Equatable, Formattable, Geometry, Intersections, Path, Point, Surface;

  Point = require('./point');

  Equatable = require('./equatable');

  Formattable = require('./formattable');

  Geometry = require('./geometry');

  Surface = require('./surface');

  Path = require('./path');

  Intersections = require('./intersections');

  Circle = (function() {

    Equatable('x', 'y', 'radius').attachTo(Circle);

    Formattable('Circle', 'x', 'y', 'radius').attachTo(Circle);

    Geometry.attachTo(Circle);

    Surface.attachTo(Circle);

    Path.attachTo(Circle);

    Intersections.attachTo(Circle);

    function Circle(radiusOrCircle, x, y, segments) {
      var _ref;
      _ref = this.circleFrom(radiusOrCircle, x, y, segments), this.radius = _ref[0], this.x = _ref[1], this.y = _ref[2], this.segments = _ref[3];
    }

    Circle.prototype.center = function() {
      return new Point(this.x, this.y);
    };

    Circle.prototype.top = function() {
      return this.y - this.radius;
    };

    Circle.prototype.bottom = function() {
      return this.y + this.radius;
    };

    Circle.prototype.left = function() {
      return this.x - this.radius;
    };

    Circle.prototype.right = function() {
      return this.x + this.radius;
    };

    Circle.prototype.points = function() {
      var n, step, _i, _ref, _results;
      step = 360 / this.segments;
      _results = [];
      for (n = _i = 0, _ref = this.segments; 0 <= _ref ? _i <= _ref : _i >= _ref; n = 0 <= _ref ? ++_i : --_i) {
        _results.push(this.pointAtAngle(n * step));
      }
      return _results;
    };

    Circle.prototype.closedGeometry = function() {
      return true;
    };

    Circle.prototype.pointAtAngle = function(angle) {
      return new Point(this.x + Math.cos(Math.degToRad(angle)) * this.radius, this.y + Math.sin(Math.degToRad(angle)) * this.radius);
    };

    Circle.prototype.acreage = function() {
      return this.radius * this.radius * Math.PI;
    };

    Circle.prototype.randomPointInSurface = function(random) {
      var center, dif, pt;
      if (random == null) {
        random = new chancejs.Random(new chancejs.MathRandom);
      }
      pt = this.pointAtAngle(random.random(360));
      center = this.center();
      dif = pt.subtract(center);
      return center.add(dif.scale(Math.sqrt(random.random())));
    };

    Circle.prototype.contains = function(xOrPt, y) {
      var x, _ref;
      _ref = Point.coordsFrom(xOrPt, y, true), x = _ref[0], y = _ref[1];
      return this.center().subtract(x, y).length() <= this.radius;
    };

    Circle.prototype.length = function() {
      return this.radius * Math.PI * 2;
    };

    Circle.prototype.pathPointAt = function(n) {
      return this.pointAtAngle(n * 360);
    };

    Circle.prototype.drawPath = function(context) {
      context.beginPath();
      return context.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    };

    Circle.prototype.clone = function() {
      return new Circle(this);
    };

    Circle.prototype.circleFrom = function(radiusOrCircle, x, y, segments) {
      var radius;
      radius = radiusOrCircle;
      if (typeof radiusOrCircle === 'object') {
        radius = radiusOrCircle.radius, x = radiusOrCircle.x, y = radiusOrCircle.y, segments = radiusOrCircle.segments;
      }
      if (!Point.isFloat(radius)) {
        radius = 1;
      }
      if (!Point.isFloat(x)) {
        x = 0;
      }
      if (!Point.isFloat(y)) {
        y = 0;
      }
      if (!Point.isFloat(segments)) {
        segments = 36;
      }
      return [radius, x, y, segments];
    };

    return Circle;

  })();

  module.exports = Circle;

}).call(this);
