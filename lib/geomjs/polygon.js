// Generated by CoffeeScript 1.4.0
(function() {
  var Cloneable, Equatable, Formattable, Geometry, Intersections, Path, Point, Polygon, Sourcable, Surface, Triangulable;

  Point = require('./point');

  Equatable = require('./mixins/equatable');

  Cloneable = require('./mixins/cloneable');

  Sourcable = require('./mixins/sourcable');

  Formattable = require('./mixins/formattable');

  Triangulable = require('./mixins/triangulable');

  Geometry = require('./mixins/geometry');

  Surface = require('./mixins/surface');

  Path = require('./mixins/path');

  Intersections = require('./mixins/intersections');

  Polygon = (function() {

    Formattable('Polygon', 'vertices').attachTo(Polygon);

    Sourcable('geomjs.Polygon', 'vertices').attachTo(Polygon);

    Cloneable.attachTo(Polygon);

    Geometry.attachTo(Polygon);

    Intersections.attachTo(Polygon);

    Triangulable.attachTo(Polygon);

    Surface.attachTo(Polygon);

    Path.attachTo(Polygon);

    Polygon.polygonFrom = function(vertices) {
      var isArray;
      if ((vertices != null) && typeof vertices === 'object') {
        isArray = Object.prototype.toString.call(vertices).indexOf('Array') !== -1;
        if (!isArray) {
          return vertices;
        }
        return {
          vertices: vertices
        };
      } else {
        return {
          vertices: null
        };
      }
    };

    function Polygon(vertices) {
      vertices = this.polygonFrom(vertices).vertices;
      if (vertices == null) {
        this.noVertices();
      }
      if (vertices.length < 3) {
        this.notEnougthVertices(vertices);
      }
      this.vertices = vertices;
    }

    Polygon.prototype.center = function() {
      var vertex, x, y, _i, _len, _ref;
      x = y = 0;
      _ref = this.vertices;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        vertex = _ref[_i];
        x += vertex.x;
        y += vertex.y;
      }
      x = x / this.vertices.length;
      y = y / this.vertices.length;
      return new Point(x, y);
    };

    Polygon.prototype.translate = function(x, y) {
      var vertex, _i, _len, _ref, _ref1;
      _ref = Point.pointFrom(x, y), x = _ref.x, y = _ref.y;
      _ref1 = this.vertices;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        vertex = _ref1[_i];
        vertex.x += x;
        vertex.y += y;
      }
      return this;
    };

    Polygon.prototype.rotateAroundCenter = function(rotation) {
      var center, i, vertex, _i, _len, _ref;
      if (rotation == null) {
        rotation = 0;
      }
      center = this.center();
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        vertex = _ref[i];
        this.vertices[i] = vertex.rotateAround(center, rotation);
      }
      return this;
    };

    Polygon.prototype.scaleAroundCenter = function(scale) {
      var center, i, vertex, _i, _len, _ref;
      center = this.center();
      _ref = this.vertices;
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        vertex = _ref[i];
        this.vertices[i] = center.add(vertex.subtract(center).scale(scale));
      }
      return this;
    };

    Polygon.prototype.points = function() {
      return this.vertices.concat(this.vertices[0]);
    };

    Polygon.prototype.closedGeometry = function() {
      return true;
    };

    Polygon.prototype.pointAtAngle = function(angle) {
      var center, distance, vec, _ref;
      center = this.center();
      distance = function(a, b) {
        return a.distance(center) - b.distance(center);
      };
      vec = center.add(Math.cos(Math.degToRad(angle)) * 10000, Math.sin(Math.degToRad(angle)) * 10000);
      return (_ref = this.intersections({
        points: function() {
          return [center, vec];
        }
      })) != null ? _ref.sort(distance)[0] : void 0;
    };

    Polygon.prototype.acreage = function() {
      var acreage, tri, _i, _len, _ref;
      acreage = 0;
      _ref = this.triangles();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tri = _ref[_i];
        acreage += tri.acreage();
      }
      return acreage;
    };

    Polygon.prototype.contains = function(x, y) {
      var tri, _i, _len, _ref;
      _ref = this.triangles();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        tri = _ref[_i];
        if (tri.contains(x, y)) {
          return true;
        }
      }
      return false;
    };

    Polygon.prototype.randomPointInSurface = function(random) {
      var acreage, i, n, ratios, triangles, _i, _len;
      if (random == null) {
        random = new chancejs.Random(new chancejs.MathRandom);
      }
      acreage = this.acreage();
      triangles = this.triangles();
      ratios = triangles.map(function(t, i) {
        return t.acreage() / acreage;
      });
      for (i = _i = 0, _len = ratios.length; _i < _len; i = ++_i) {
        n = ratios[i];
        if (i > 0) {
          ratios[i] += ratios[i - 1];
        }
      }
      return random.inArray(triangles, ratios, true).randomPointInSurface(random);
    };

    Polygon.prototype.length = function() {
      var i, length, points, _i, _ref;
      length = 0;
      points = this.points();
      for (i = _i = 1, _ref = points.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        length += points[i - 1].distance(points[i]);
      }
      return length;
    };

    Polygon.prototype.memoizationKey = function() {
      return this.vertices.map(function(pt) {
        return "" + pt.x + "," + pt.y;
      }).join(";");
    };

    Polygon.prototype.polygonFrom = Polygon.polygonFrom;

    Polygon.prototype.noVertices = function() {
      throw new Error('No vertices provided to Polygon');
    };

    Polygon.prototype.notEnougthVertices = function(vertices) {
      var length;
      length = vertices.length;
      throw new Error("Polygon must have at least 3 vertices, was " + length);
    };

    return Polygon;

  })();

  module.exports = Polygon;

}).call(this);
