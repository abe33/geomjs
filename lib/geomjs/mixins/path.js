// Generated by CoffeeScript 1.4.0
(function() {
  var Mixin, Path, Point,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixin = require('./mixin');

  Point = require('../point');

  Path = (function(_super) {

    __extends(Path, _super);

    function Path() {
      return Path.__super__.constructor.apply(this, arguments);
    }

    Path.prototype.length = function() {
      return null;
    };

    Path.prototype.pathPointAt = function(pos, pathBasedOnLength) {
      var points;
      if (pathBasedOnLength == null) {
        pathBasedOnLength = true;
      }
      if (pos < 0) {
        pos = 0;
      }
      if (pos > 1) {
        pos = 1;
      }
      points = this.points();
      if (pos === 0) {
        return points[0];
      }
      if (pos === 1) {
        return points[points.length - 1];
      }
      if (pathBasedOnLength) {
        return this.walkPathBasedOnLength(pos, points);
      } else {
        return this.walkPathBasedOnSegments(pos, points);
      }
    };

    Path.prototype.pathOrientationAt = function(n, pathBasedOnLength) {
      var d, p1, p2;
      if (pathBasedOnLength == null) {
        pathBasedOnLength = true;
      }
      p1 = this.pathPointAt(n - 0.01);
      p2 = this.pathPointAt(n + 0.01);
      d = p2.subtract(p1);
      return d.angle();
    };

    Path.prototype.pathTangentAt = function(n, accuracy, pathBasedOnLength) {
      if (accuracy == null) {
        accuracy = 1 / 100;
      }
      if (pathBasedOnLength == null) {
        pathBasedOnLength = true;
      }
      return this.pathPointAt((n + accuracy) % 1).subtract(this.pathPointAt((1 + n - accuracy) % 1)).normalize(1);
    };

    Path.prototype.walkPathBasedOnLength = function(pos, points) {
      var i, innerStepPos, length, p1, p2, stepLength, walked, _i, _ref;
      walked = 0;
      length = this.length();
      for (i = _i = 1, _ref = points.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        p1 = points[i - 1];
        p2 = points[i];
        stepLength = p1.distance(p2) / length;
        if (walked + stepLength > pos) {
          innerStepPos = Math.map(pos, walked, walked + stepLength, 0, 1);
          return p1.add(p2.subtract(p1).scale(innerStepPos));
        }
        walked += stepLength;
      }
    };

    Path.prototype.walkPathBasedOnSegments = function(pos, points) {
      var segment, segments;
      segments = points.length - 1;
      pos = pos * segments;
      segment = Math.floor(pos);
      if (segment === segments) {
        segment -= 1;
      }
      return Point.interpolate(points[segment], points[segment + 1], pos - segment);
    };

    return Path;

  })(Mixin);

  module.exports = Path;

}).call(this);
