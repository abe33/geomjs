// Generated by CoffeeScript 1.4.0
(function() {
  var Memoizable, Mixin, Point, Triangle, Triangulable,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixin = require('./mixin');

  Memoizable = require('./memoizable');

  Triangle = require('../triangle');

  Point = require('../point');

  Triangulable = (function(_super) {
    var arrayCopy, pointInTriangle, polyArea, triangulate;

    __extends(Triangulable, _super);

    function Triangulable() {
      return Triangulable.__super__.constructor.apply(this, arguments);
    }

    Memoizable.attachTo(Triangulable);

    arrayCopy = function(arrayTo, arrayFrom) {
      var i, n, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = arrayFrom.length; _i < _len; i = ++_i) {
        n = arrayFrom[i];
        _results.push(arrayTo[i] = n);
      }
      return _results;
    };

    pointInTriangle = function(pt, v1, v2, v3) {
      var b1, b2, b3, denom;
      denom = (v1.y - v3.y) * (v2.x - v3.x) + (v2.y - v3.y) * (v3.x - v1.x);
      b1 = ((pt.y - v3.y) * (v2.x - v3.x) + (v2.y - v3.y) * (v3.x - pt.x)) / denom;
      b2 = ((pt.y - v1.y) * (v3.x - v1.x) + (v3.y - v1.y) * (v1.x - pt.x)) / denom;
      b3 = ((pt.y - v2.y) * (v1.x - v2.x) + (v1.y - v2.y) * (v2.x - pt.x)) / denom;
      if (b1 < 0 || b2 < 0 || b3 < 0) {
        return false;
      }
      return true;
    };

    polyArea = function(pts) {
      var i, l, sum, _i, _ref;
      sum = 0;
      i = 0;
      l = pts.length;
      for (i = _i = 0, _ref = l - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        sum += pts[i].x * pts[(i + 1) % l].y - pts[(i + 1) % l].x * pts[i].y;
      }
      return sum / 2;
    };

    triangulate = function(vertices) {
      var cr, i, j, l, n, nr, ok, pArea, pts, ptsArea, r1, r2, r3, refs, tArea, triangulated, v1, v2, v3;
      if (vertices.length < 4) {
        return;
      }
      pts = vertices;
      refs = (function() {
        var _i, _len, _results;
        _results = [];
        for (i = _i = 0, _len = pts.length; _i < _len; i = ++_i) {
          n = pts[i];
          _results.push(i);
        }
        return _results;
      })();
      ptsArea = [];
      i = 0;
      l = refs.length;
      while (i < l) {
        ptsArea[i] = pts[refs[i]].clone();
        ++i;
      }
      pArea = polyArea(ptsArea);
      cr = [];
      nr = [];
      arrayCopy(cr, refs);
      while (cr.length > 3) {
        i = 0;
        l = cr.length;
        while (i < l) {
          r1 = cr[i % l];
          r2 = cr[(i + 1) % l];
          r3 = cr[(i + 2) % l];
          v1 = pts[r1];
          v2 = pts[r2];
          v3 = pts[r3];
          ok = true;
          j = (i + 3) % l;
          while (j !== i) {
            ptsArea = [v1, v2, v3];
            tArea = polyArea(ptsArea);
            if ((pArea < 0 && tArea > 0) || (pArea > 0 && tArea < 0) || pointInTriangle(pts[cr[j]], v1, v2, v3)) {
              ok = false;
              break;
            }
            j = (j + 1) % l;
          }
          if (ok) {
            nr.push(r1, r2, r3);
            cr.splice((i + 1) % l, 1);
            break;
          }
          ++i;
        }
      }
      nr.push.apply(nr, cr.slice(0, 3));
      triangulated = true;
      return nr;
    };

    Triangulable.prototype.triangles = function() {
      var a, b, c, i, index, indices, triangles, vertices, _i, _ref;
      if (this.memoized('triangles')) {
        return this.memoFor('triangles');
      }
      vertices = this.points();
      vertices.pop();
      indices = triangulate(vertices);
      triangles = [];
      for (i = _i = 0, _ref = indices.length / 3 - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        index = i * 3;
        a = vertices[indices[index]];
        b = vertices[indices[index + 1]];
        c = vertices[indices[index + 2]];
        triangles.push(new Triangle(a, b, c));
      }
      return this.memoize('triangles', triangles);
    };

    return Triangulable;

  })(Mixin);

  module.exports = Triangulable;

}).call(this);
