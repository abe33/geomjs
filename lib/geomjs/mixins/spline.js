// Generated by CoffeeScript 1.4.0
(function() {
  var Memoizable, Mixin, Point, Spline,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixin = require('./mixin');

  Memoizable = require('./memoizable');

  Point = require('../point');

  Spline = function(segmentSize) {
    var _;
    return _ = (function(_super) {

      __extends(_, _super);

      function _() {
        return _.__super__.constructor.apply(this, arguments);
      }

      Memoizable.attachTo(_);

      _.included = function(klass) {
        return klass.prototype.clone = function() {
          return new klass(this.vertices.map(function(pt) {
            return pt.clone();
          }), this.bias);
        };
      };

      _.prototype.initSpline = function(vertices, bias) {
        this.vertices = vertices;
        this.bias = bias != null ? bias : 20;
        if (!this.validateVertices(this.vertices)) {
          throw new Error("The number of vertices for " + this + " doesn't match");
        }
      };

      _.prototype.validateVertices = function() {
        return true;
      };

      _.prototype.segmentSize = function() {
        return segmentSize;
      };

      _.prototype.segment = function(index) {
        if (index < this.segments()) {
          return this.vertices.concat().slice(index * segmentSize, (index + 1) * segmentSize + 1);
        } else {
          return null;
        }
      };

      _.prototype.pointInSegment = function(position, segment) {
        return Point.interpolate(segment[0], segment[1], position);
      };

      _.prototype.length = function() {
        return this.measure(this.bias);
      };

      _.prototype.measure = function(bias) {
        var i, length, _i, _ref;
        length = 0;
        for (i = _i = 0, _ref = this.segments() - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          length += this.measureSegment(this.segment(i), bias);
        }
        return length;
      };

      _.prototype.measureSegment = function(segment, bias) {
        var i, length, step, _i;
        step = 1 / bias;
        length = 0;
        for (i = _i = 1; 1 <= bias ? _i <= bias : _i >= bias; i = 1 <= bias ? ++_i : --_i) {
          length += this.pointInSegment((i - 1) * step, segment).distance(this.pointInSegment(i * step, segment));
        }
        return length;
      };

      _.prototype.pathPointAt = function(pos, pathBasedOnLength) {
        if (pathBasedOnLength == null) {
          pathBasedOnLength = true;
        }
        if (pos < 0) {
          pos = 0;
        }
        if (pos > 1) {
          pos = 1;
        }
        if (pos === 0) {
          return this.vertices[0];
        }
        if (pos === 1) {
          return this.vertices[this.vertices.length - 1];
        }
        if (pathBasedOnLength) {
          return this.walkPathBasedOnLength(pos);
        } else {
          return this.walkPathBasedOnSegments(pos);
        }
      };

      _.prototype.walkPathBasedOnLength = function(pos) {
        var i, innerStepPos, length, p1, p2, points, stepLength, walked, _i, _ref;
        walked = 0;
        length = this.length();
        points = this.points();
        for (i = _i = 1, _ref = points.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          p1 = points[i - 1];
          p2 = points[i];
          stepLength = p1.distance(p2) / length;
          if (walked + stepLength > pos) {
            innerStepPos = Math.map(pos, walked, walked + stepLength, 0, 1);
            return p1.add(p2.subtract(p1).scale(innerStepPos));
          }
          walked += stepLength;
        }
      };

      _.prototype.walkPathBasedOnSegments = function(pos) {
        var segment, segments;
        segments = this.segments();
        pos = pos * segments;
        segment = Math.floor(pos);
        if (segment === segments) {
          segment -= 1;
        }
        return this.pointInSegment(pos - segment, this.segment(segment));
      };

      _.prototype.drawVertices = function(context, color) {
        var vertex, _i, _len, _ref, _results;
        context.fillStyle = color;
        _ref = this.vertices;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vertex = _ref[_i];
          context.beginPath();
          context.arc(vertex.x, vertex.y, 2, 0, Math.PI * 2);
          context.fill();
          _results.push(context.closePath());
        }
        return _results;
      };

      return _;

    })(Mixin);
  };

  module.exports = Spline;

}).call(this);
