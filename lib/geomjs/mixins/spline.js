// Generated by CoffeeScript 1.4.0
(function() {
  var Memoizable, Mixin, Point, Spline,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixin = require('./mixin');

  Memoizable = require('./memoizable');

  Point = require('../point');

  Spline = function(segmentSize) {
    var ConcretSpline;
    return ConcretSpline = (function(_super) {

      __extends(ConcretSpline, _super);

      function ConcretSpline() {
        return ConcretSpline.__super__.constructor.apply(this, arguments);
      }

      Memoizable.attachTo(ConcretSpline);

      ConcretSpline.included = function(klass) {
        return klass.prototype.clone = function() {
          return new klass(this.vertices.map(function(pt) {
            return pt.clone();
          }), this.bias);
        };
      };

      ConcretSpline.prototype.initSpline = function(vertices, bias) {
        this.vertices = vertices;
        this.bias = bias != null ? bias : 20;
        if (!this.validateVertices(this.vertices)) {
          throw new Error("The number of vertices for " + this + " doesn't match");
        }
      };

      ConcretSpline.prototype.points = function() {
        var i, points, segments;
        if (this.memoized('points')) {
          return this.memoFor('points').concat();
        }
        segments = this.segments() * this.bias;
        points = (function() {
          var _i, _results;
          _results = [];
          for (i = _i = 0; 0 <= segments ? _i <= segments : _i >= segments; i = 0 <= segments ? ++_i : --_i) {
            _results.push(this.pathPointAt(i / segments));
          }
          return _results;
        }).call(this);
        return this.memoize('points', points).concat();
      };

      ConcretSpline.prototype.validateVertices = function(vertices) {
        return vertices.length % segmentSize === 1 && vertices.length >= segmentSize + 1;
      };

      ConcretSpline.prototype.segments = function() {
        if (!(this.vertices != null) || this.vertices.length === 0) {
          return 0;
        }
        if (this.memoized('segments')) {
          return this.memoFor('segments');
        }
        return this.memoize('segments', (this.vertices.length - 1) / segmentSize);
      };

      ConcretSpline.prototype.segmentSize = function() {
        return segmentSize;
      };

      ConcretSpline.prototype.segment = function(index) {
        var k;
        if (index < this.segments()) {
          k = "segment" + index;
          if (this.memoized(k)) {
            return this.memoFor(k);
          }
          return this.memoize(k, this.vertices.concat().slice(index * segmentSize, (index + 1) * segmentSize + 1));
        } else {
          return null;
        }
      };

      ConcretSpline.prototype.length = function() {
        if (this.memoized('length')) {
          return this.memoFor('length');
        }
        return this.memoize('length', this.measure(this.bias));
      };

      ConcretSpline.prototype.measure = function(bias) {
        var i, length, _i, _ref;
        length = 0;
        for (i = _i = 0, _ref = this.segments() - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          length += this.measureSegment(this.segment(i), bias);
        }
        return length;
      };

      ConcretSpline.prototype.measureSegment = function(segment, bias) {
        var i, k, length, step, _i;
        k = "segment" + segment + "_" + bias + "Length";
        if (this.memoized(k)) {
          return this.memoFor(k);
        }
        step = 1 / bias;
        length = 0;
        for (i = _i = 1; 1 <= bias ? _i <= bias : _i >= bias; i = 1 <= bias ? ++_i : --_i) {
          length += this.pointInSegment((i - 1) * step, segment).distance(this.pointInSegment(i * step, segment));
        }
        return this.memoize(k, length);
      };

      ConcretSpline.prototype.pathPointAt = function(pos, pathBasedOnLength) {
        if (pathBasedOnLength == null) {
          pathBasedOnLength = true;
        }
        if (pos < 0) {
          pos = 0;
        }
        if (pos > 1) {
          pos = 1;
        }
        if (pos === 0) {
          return this.vertices[0];
        }
        if (pos === 1) {
          return this.vertices[this.vertices.length - 1];
        }
        if (pathBasedOnLength) {
          return this.walkPathBasedOnLength(pos);
        } else {
          return this.walkPathBasedOnSegments(pos);
        }
      };

      ConcretSpline.prototype.walkPathBasedOnLength = function(pos) {
        var i, innerStepPos, length, segment, segments, stepLength, walked, _i, _ref;
        walked = 0;
        length = this.length();
        segments = this.segments();
        for (i = _i = 0, _ref = segments - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          segment = this.segment(i);
          stepLength = this.measureSegment(segment, this.bias) / length;
          if (walked + stepLength > pos) {
            innerStepPos = Math.map(pos, walked, walked + stepLength, 0, 1);
            return this.pointInSegment(innerStepPos, segment);
          }
          walked += stepLength;
        }
      };

      ConcretSpline.prototype.walkPathBasedOnSegments = function(pos) {
        var segment, segments;
        segments = this.segments();
        pos = pos * segments;
        segment = Math.floor(pos);
        if (segment === segments) {
          segment -= 1;
        }
        return this.pointInSegment(pos - segment, this.segment(segment));
      };

      ConcretSpline.prototype.fill = function() {};

      ConcretSpline.prototype.drawPath = function(context) {
        var p, points, start, _i, _len, _results;
        points = this.points();
        start = points.shift();
        context.beginPath();
        context.moveTo(start.x, start.y);
        _results = [];
        for (_i = 0, _len = points.length; _i < _len; _i++) {
          p = points[_i];
          _results.push(context.lineTo(p.x, p.y));
        }
        return _results;
      };

      ConcretSpline.prototype.drawVertices = function(context, color) {
        var vertex, _i, _len, _ref, _results;
        context.fillStyle = color;
        _ref = this.vertices;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vertex = _ref[_i];
          context.beginPath();
          context.arc(vertex.x, vertex.y, 2, 0, Math.PI * 2);
          context.fill();
          _results.push(context.closePath());
        }
        return _results;
      };

      ConcretSpline.prototype.drawVerticesConnections = function(context, color) {
        var i, vertexEnd, vertexStart, _i, _ref, _results;
        context.strokeStyle = color;
        _results = [];
        for (i = _i = 1, _ref = this.vertices.length - 1; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          vertexStart = this.vertices[i - 1];
          vertexEnd = this.vertices[i];
          context.beginPath();
          context.moveTo(vertexStart.x, vertexStart.y);
          context.lineTo(vertexEnd.x, vertexEnd.y);
          context.stroke();
          _results.push(context.closePath());
        }
        return _results;
      };

      ConcretSpline.prototype.memoizationKey = function() {
        return this.vertices.map(function(pt) {
          return "" + pt.x + ";" + pt.y;
        }).join(';');
      };

      return ConcretSpline;

    })(Mixin);
  };

  module.exports = Spline;

}).call(this);
