// Generated by CoffeeScript 1.4.0
(function() {
  var Intersections, Mixin, Point,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Mixin = require('./mixin');

  Point = require('../point');

  Intersections = (function(_super) {

    __extends(Intersections, _super);

    function Intersections() {
      return Intersections.__super__.constructor.apply(this, arguments);
    }

    Intersections.iterators = {};

    Intersections.prototype.intersects = function(geometry) {
      var iterator, output;
      if ((geometry.bounds != null) && !this.boundsCollide(geometry)) {
        return false;
      }
      output = false;
      iterator = this.intersectionsIterator(this, geometry);
      iterator.call(this, this, geometry, function() {
        return output = true;
      });
      return output;
    };

    Intersections.prototype.intersections = function(geometry) {
      var iterator, output;
      if ((geometry.bounds != null) && !this.boundsCollide(geometry)) {
        return null;
      }
      output = [];
      iterator = this.intersectionsIterator(this, geometry);
      iterator.call(this, this, geometry, function(intersection) {
        output.push(intersection);
        return false;
      });
      if (output.length > 0) {
        return output;
      } else {
        return null;
      }
    };

    Intersections.prototype.boundsCollide = function(geometry) {
      var bounds1, bounds2;
      bounds1 = this.bounds();
      bounds2 = geometry.bounds();
      return !(bounds1.top > bounds2.bottom || bounds1.left > bounds2.right || bounds1.bottom < bounds2.top || bounds1.right < bounds2.left);
    };

    Intersections.prototype.intersectionsIterator = function(geom1, geom2) {
      var c1, c2, iterator;
      c1 = geom1.classname ? geom1.classname() : '';
      c2 = geom2.classname ? geom2.classname() : '';
      iterator = null;
      iterator = Intersections.iterators[c1 + c2];
      iterator || (iterator = Intersections.iterators[c1]);
      iterator || (iterator = Intersections.iterators[c2]);
      return iterator || this.eachIntersections;
    };

    Intersections.prototype.eachIntersections = function(geom1, geom2, block, providesDataInCallback) {
      var context, cross, d1l, d1x, d1y, d2l, d2x, d2y, d3l, d3x, d3y, d4l, d4x, d4y, dif1l, dif1x, dif1y, dif2l, dif2x, dif2y, ev1, ev2, i, j, lastIntersection, length1, length2, points1, points2, sv1, sv2, _i, _j, _ref, _ref1;
      if (providesDataInCallback == null) {
        providesDataInCallback = false;
      }
      points1 = geom1.points();
      points2 = geom2.points();
      length1 = points1.length;
      length2 = points2.length;
      lastIntersection = null;
      for (i = _i = 0, _ref = length1 - 2; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        sv1 = points1[i];
        ev1 = points1[i + 1];
        dif1x = ev1.x - sv1.x;
        dif1y = ev1.y - sv1.y;
        dif1l = dif1x * dif1x + dif1y * dif1y;
        for (j = _j = 0, _ref1 = length2 - 2; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          sv2 = points2[j];
          ev2 = points2[j + 1];
          dif2x = ev2.x - sv2.x;
          dif2y = ev2.y - sv2.y;
          dif2l = dif2x * dif2x + dif2y * dif2y;
          cross = this.perCrossing(sv1, {
            x: dif1x,
            y: dif1y
          }, sv2, {
            x: dif2x,
            y: dif2y
          });
          d1x = cross.x - ev1.x;
          d1y = cross.y - ev1.y;
          d2x = cross.x - sv1.x;
          d2y = cross.y - sv1.y;
          d3x = cross.x - ev2.x;
          d3y = cross.y - ev2.y;
          d4x = cross.x - sv2.x;
          d4y = cross.y - sv2.y;
          d1l = d1x * d1x + d1y * d1y;
          d2l = d2x * d2x + d2y * d2y;
          d3l = d3x * d3x + d3y * d3y;
          d4l = d4x * d4x + d4y * d4y;
          if (d1l <= dif1l && d2l <= dif1l && d3l <= dif2l && d4l <= dif2l) {
            if (cross.equals(lastIntersection)) {
              lastIntersection = cross;
              continue;
            }
            if (providesDataInCallback) {
              context = {
                segment1: new Point(dif1x, dif1y),
                segmentIndex1: i,
                segmentStart1: sv1,
                segmentEnd1: ev1,
                segment2: new Point(dif2x, dif2y),
                segmentIndex2: j,
                segmentStart2: sv2,
                segmentEnd2: ev2
              };
            }
            if (block.call(this, cross, context)) {
              return;
            }
            lastIntersection = cross;
          }
        }
      }
    };

    Intersections.prototype.perCrossing = function(start1, dir1, start2, dir2) {
      var cx, cy, perP1, perP2, t, v3bx, v3by;
      v3bx = start2.x - start1.x;
      v3by = start2.y - start1.y;
      perP1 = v3bx * dir2.y - v3by * dir2.x;
      perP2 = dir1.x * dir2.y - dir1.y * dir2.x;
      t = perP1 / perP2;
      cx = start1.x + dir1.x * t;
      cy = start1.y + dir1.y * t;
      return new Point(cx, cy);
    };

    return Intersections;

  })(Mixin);

  module.exports = Intersections;

}).call(this);
